{"version":3,"file":"lib.min.js","sources":["../src/lib.js"],"sourcesContent":["/**\n *\n * @module      mod_nextblocks/lib\n * @copyright   2025 Rui Correia<rjr.correia@campus.fct.unl.pt>\n * @copyright   based on work by 2024 Duarte Pereira<dg.pereira@campus.fct.unl.pt>\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/* globals Blockly */\n\ndefine(['mod_nextblocks/codestring', 'mod_nextblocks/codestringPython', 'core/str'], function(CodeString, CodeStringPython, str) {\n        /**\n         * @param {BlockSvg} block the block whose code is to be generated\n         * @returns {string} the code generated by Blockly for the given block\n         */\n        function generateFunctionCode(block) {\n            Blockly.JavaScript.blockToCode(block);\n            // Get function name\n            let functionName = '%' + Blockly.JavaScript.nameDB_.getName(block.getFieldValue('NAME'),\n                Blockly.Procedures.NAME_TYPE);\n            functionName = functionName.substring(0, functionName.length - 1);\n            return Blockly.JavaScript.definitions_[functionName] + '\\n';\n        }\n\n    /**\n     * @param {BlockSvg} block the block whose code is to be generated\n     * @returns {string} the code generated by Blockly for the given block\n     */\n    function generateFunctionCodePython(block) {\n        Blockly.Python.blockToCode(block);\n        // Get function name\n        let functionName = '%' + Blockly.Python.nameDB_.getName(block.getFieldValue('NAME'),\n            Blockly.Procedures.NAME_TYPE);\n        functionName = functionName.substring(0, functionName.length - 1);\n        return Blockly.Python.definitions_[functionName] + '\\n';\n    }\n\n        /**\n         * @param {BlockSvg} block the block whose descendants are to have their code generated\n         * @returns {string} the code generated by Blockly for the descendants of the given block\n         */\n        function generateDescendantsCode(block) {\n            let descendantsCode = '';\n            block.getChildren(true).forEach((child) => {\n                descendantsCode += Blockly.JavaScript.blockToCode(child);\n            });\n            return descendantsCode;\n        }\n\n    /**\n     * @param {BlockSvg} block the block whose descendants are to have their code generated\n     * @returns {string} the code generated by Blockly for the descendants of the given block\n     */\n    function generateDescendantsCodePython(block) {\n        let descendantsCode = '';\n        block.getChildren(true).forEach((child) => {\n            descendantsCode += Blockly.Python.blockToCode(child);\n        });\n        return descendantsCode;\n    }\n\n        return {\n            /**\n             * @param {String} code The Javascript code to be run\n             * @returns {any} The output of the code\n             * Runs the code and returns the output, does not display it\n             * TODO: do something other than use eval\n             */\n            silentRunCode: async function(code) {\n                /* eslint-disable no-eval */\n                const result = await eval(code);\n                return typeof result === 'undefined' ? code : result;\n            },\n\n            /**\n             * Formats the code with correct HTML structure to be displayed in the code div\n             * @param {CodeString} code the code text to be formatted (string literal)\n             * @param {boolean} debugMode whether to display the code as is, or with the wrapper function\n             * @returns {string} the formatted code\n             */\n            formatCodeHTML: (code, debugMode = false) => {\n                if (!debugMode) {\n                    return '<pre>' + code.getPrintableCodeString() + '</pre>';\n                } else {\n                    return '<pre>' + code.getCompleteCodeString() + '</pre>';\n                }\n            },\n\n            /**\n             * Formats the code with correct HTML structure to be displayed in the code div\n             * @param {CodeStringPython} code the code text to be formatted (string literal)\n             * @param {boolean} debugMode whether to display the code as is, or with the wrapper function\n             * @returns {string} the formatted code\n             */\n            formatPythonCodeHTML: (code, debugMode = false) => {\n                if (!debugMode) {\n                    return '<pre>' + code.getPrintableCodeString() + '</pre>';\n                } else {\n                    return '<pre>' + code.getCompleteCodeString() + '</pre>';\n                }\n            },\n\n            /**\n             * Inserts the test results accordion in the area above the Run and Tests buttons\n             * @param {any[]|null} results the outputs of the tests\n             * @param {{}} testsJSON the tests that were run (for displaying the inputs and outputs)\n             * Note: if this is not empty, results is null\n             * @returns {string} the HTML for the accordion\n             */\n            testsAccordion: async function(results, testsJSON) {\n                const testCaseCount = testsJSON.length;\n                let accordion = '<div class=\"d-flex flex-wrap\" style=\"max-height: 100%; overflow-y: auto;\">';\n                let strtest = await str.get_string('test', 'mod_nextblocks');\n                let strtestnotrun = await str.get_string('testnotrun', 'mod_nextblocks');\n                let strtesterror = await str.get_string('testerror', 'mod_nextblocks');\n                let strtestpassed = await str.get_string('testpassed', 'mod_nextblocks');\n                let strtestfailed = await str.get_string('testfailed', 'mod_nextblocks');\n                let strtestinput = await str.get_string('testinput', 'mod_nextblocks');\n                let strexpectedtestoutput = await str.get_string('expectedtestoutput', 'mod_nextblocks');\n                let stryouroutput = await str.get_string('youroutput', 'mod_nextblocks');\n                for (let i = 0; i < testCaseCount; i++) {\n                    accordion += '<div class=\"card m-2\" style=\"flex: 1 1 calc(25% - 20px); min-width: 250px;\">';\n                    accordion += '<details class=\"card-body\">';\n                    accordion += '<summary class=\"card-header\" style=\"border-bottom: none;\">';\n                    accordion += strtest + (i + 1);\n\n                    if (results === null || results[i] === undefined) {\n                        accordion += '<span class=\"badge badge-warning float-right\">' + strtestnotrun + '</span>';\n                    } else if (results[i].includes(\"Error\")) {\n                        accordion += '<span class=\"badge badge-warning float-right\" style=\"color: black !important;\">'\n                            + strtesterror + '</span>';\n                    } else if (results[i] === testsJSON[i].output) {\n                        accordion += '<span class=\"badge badge-success float-right\" style=\"color: green !important;\">'\n                            + strtestpassed + '</span>';\n                    } else {\n                        accordion += '<span class=\"badge badge-danger float-right\" style=\"color: red !important;\">'\n                            + strtestfailed + '</span>';\n                    }\n                    accordion += '</summary>';\n\n                    accordion += '<div class=\"pt-2\" style=\"background-color: white !important;\">';\n                    /* eslint-disable no-loop-func */\n                    testsJSON[i].inputs.forEach((input) => {\n                        const prompt = Object.keys(input)[0];\n                        const values = Object.values(input[prompt])[0];\n                        const combination = [prompt].concat(values);\n\n                        let inputString = \"\";\n                        for (const v of combination) {\n                            inputString += v;\n                            inputString += \"\\n\";\n                        }\n\n                        accordion += '<p class=\"pt-2 m-0\">' + strtestinput + '</p>';\n                        accordion += '<pre class=\"mt-1 mb-0 test-input\">' + inputString + '</pre>';\n                    });\n                    accordion += '<p class=\"pt-2 mt-2 mb-0\">' + strexpectedtestoutput + '</p>';\n                    accordion += '<pre class=\"mt-1 mb-0 test-output\">' + testsJSON[i].output + '</pre>';\n                    accordion += '<div class=\"p-0\">';\n                    accordion += '<p class=\"pt-2 m-0\">' + stryouroutput + '</p>';\n                    if (results === null) {\n                        accordion += '<pre class=\"mt-1 mb-0 test-output\">' + strtestnotrun + '</pre>';\n\n                    } else if (results[i].includes(\"Error\")) {\n                        accordion += '<pre class=\"mt-1 mb-0 test-output\" style=\"color: red !important;\">' +\n                            results[i] + '</pre>';\n                    } else {\n                        accordion += '<pre class=\"pb-2 mt-1 mb-0 test-output\">' + results[i] + '</pre>';\n                    }\n                    accordion += '</div>';\n                    accordion += '</div>';\n                    accordion += '</details>';\n                    accordion += '</div>';\n                }\n\n                accordion += '</div>';\n                return accordion;\n            },\n\n            /**\n             * Changes the code to correctly output execution errors\n             * @param {CodeString} code the code text to be formatted (string literal)\n             * @returns {string} the formatted code\n             */\n            errorPrevention: (code) => {\n                let strerrormaxtime = \"\";\n                str.get_string('errormaxtime', 'mod_nextblocks').then(function(text) {strerrormaxtime = text;});\n                // Avoid infinite loops\n                code = code.replace(/((?:while|for)\\s*\\([^)]*\\)\\s*\\{)/g,\n                    \"$1\\nif(loopIterations++>MAX_ITERATIONS) return outputString = \" +\n                    \"\\\"\" + strerrormaxtime + \"\\\";\");\n\n                return code;\n            },\n\n            /**\n             * Runs the tests on the given workspace and returns an array of booleans, one for each test, indicating whether\n             * the test passed or not\n             * @param {String} code the workspace to run the tests on\n             * @param {{}} tests the tests to run\n             * @returns {String[]} the output of each test\n             */\n            runTests: async function(code, tests) {\n                let results = [];\n                code = code.replace(\"runningTests = false;\", \"runningTests = true;\");\n\n                code = this.errorPrevention(code);\n\n                for (const test of tests) {\n                    let thisTestCode = code; // Need to copy, so that the code is not modified for the next test\n                    const inputs = test.inputs;\n                    for (const input of inputs) {\n                        const prompt = Object.keys(input)[0];\n                        const values = Object.values(input[prompt])[0];\n\n                        const combination = [prompt].concat(values);\n\n                        thisTestCode = thisTestCode.replace(\"const testInputs = [];\",\n                            \"const testInputs = [\" + combination.toString() + \"];\");\n\n                    }\n                    let codeOutput = await this.silentRunCode(thisTestCode);\n                    codeOutput = codeOutput.trim();\n                    results.push(codeOutput);\n                }\n                return results;\n            },\n\n            /**\n             * @param {WorkspaceSvg} workspace the workspace to get the code from\n             * @param {string} inputFuncDecs\n             * @returns {CodeString} the code generated by Blockly for the current workspace\n             *\n             * Returns the Javascript code string generated by Blockly, with the necessary wrapping code\n             */\n            getWorkspaceCode: function(workspace, inputFuncDecs) {\n                Blockly.JavaScript.addReservedWords('print, input');\n                let codeString = new CodeString();\n\n                codeString.addAuxFunctions(inputFuncDecs);\n\n                const functionOpen = 'await (async () => {';\n                codeString.addLine(functionOpen);\n\n                let blocks = workspace.getTopBlocks(true);\n                for (let b = 0; b < blocks.length; b++) {\n                    const block = blocks[b];\n                    if (block.type === 'start') {\n                        codeString.addMainCode(generateDescendantsCode(block));\n                    } else if (block.type === 'procedures_defnoreturn' || block.type === 'procedures_defreturn') {\n                        codeString.addFunction(generateFunctionCode(block));\n                    }\n                }\n                codeString.addEnding();\n                return codeString;\n            },\n\n            /**\n             * @param {WorkspaceSvg} workspace the workspace to get the code from\n             * @param {string} inputFuncDecs\n             * @returns {CodeStringPython} the code generated by Blockly for the current workspace\n             *\n             * Returns the Python code string generated by Blockly, with the necessary wrapping code\n             */\n            getWorkspaceCodePython: function(workspace, inputFuncDecs) {\n                Blockly.Python.addReservedWords('print, input, text_ask');\n                let codeString = new CodeStringPython();\n\n                codeString.addAuxFunctions(inputFuncDecs);\n\n                const functionOpen = 'await (async () => {';\n                codeString.addLine(functionOpen);\n\n                let blocks = workspace.getTopBlocks(true);\n                for (let b = 0; b < blocks.length; b++) {\n                    const block = blocks[b];\n                    if (block.type === 'start') {\n                        codeString.addMainCode(generateDescendantsCodePython(block));\n                    } else if (block.type === 'procedures_defnoreturn' || block.type === 'procedures_defreturn') {\n                        codeString.addFunction(generateFunctionCodePython(block));\n                    }\n                }\n                codeString.addEnding();\n                return codeString;\n            },\n        };\n});\n"],"names":["define","CodeString","CodeStringPython","str","generateFunctionCode","block","Blockly","JavaScript","blockToCode","functionName","nameDB_","getName","getFieldValue","Procedures","NAME_TYPE","substring","length","definitions_","generateFunctionCodePython","Python","generateDescendantsCode","descendantsCode","getChildren","forEach","child","generateDescendantsCodePython","silentRunCode","async","code","result","eval","formatCodeHTML","arguments","undefined","getCompleteCodeString","getPrintableCodeString","formatPythonCodeHTML","testsAccordion","results","testsJSON","testCaseCount","accordion","strtest","get_string","strtestnotrun","strtesterror","strtestpassed","strtestfailed","strtestinput","strexpectedtestoutput","stryouroutput","i","includes","output","inputs","input","prompt","Object","keys","values","combination","concat","inputString","v","errorPrevention","strerrormaxtime","then","text","replace","runTests","tests","this","test","thisTestCode","toString","codeOutput","trim","push","getWorkspaceCode","workspace","inputFuncDecs","addReservedWords","codeString","addAuxFunctions","addLine","blocks","getTopBlocks","b","type","addMainCode","addFunction","addEnding","getWorkspaceCodePython"],"mappings":"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"}