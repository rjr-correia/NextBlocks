{"version":3,"file":"codestring.min.js","sources":["../src/codestring.js"],"sourcesContent":["/**\n *\n * @module      mod_nextblocks/codestring\n * @copyright   2025 Rui Correia<rjr.correia@campus.fct.unl.pt>\n * @copyright   based on work by 2024 Duarte Pereira<dg.pereira@campus.fct.unl.pt>\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\ndefine([], function() {\n\n    class CodeString {\n        #codeString;\n        #originalCodeString;\n        #userFunctionLinesCount;\n        static #judge0codeheader = `\n        const fs = require('fs');\n        const stdin = fs.readFileSync(0, 'utf-8').trim().split('\\\\n');\n        let nextInput = 0;\n        function input(promptText) {\n          return stdin[nextInput++] || \"\";\n        }\n        \n        `;\n        static #auxFunctions =\n            `\nconst runningTests = false;\nconst testInputs = [];\nconst MAX_ITERATIONS = 10000;\nvar nextInput = 0;\nvar loopIterations = 0;\nvar error = \"\";\n\ncustomPrintln = function(string) {\n  outputString += string + '\\\\n';\n  updateTerminal();\n  return string;\n};\n\nupdateTerminal = function(){\n  if (runningTests) return;\n  const outputDiv = document.getElementById('output-div');\n  if (outputDiv) {\n    outputDiv.innerHTML = \"\";\n    const pre = document.createElement('pre');\n    pre.style.whiteSpace = 'pre-wrap'; \n    pre.textContent = outputString; \n    outputDiv.appendChild(pre);\n  }\n}\n\ntext_to_number = function(string){\n    let result = parseFloat(string);\n    if (isNaN(result)){\n        if (error.length == 0) error = \"Error: Cannot convert \"  + string + \" to a number.\";\n        return 0;\n    }\n    return result;\n}\n\nasync function input(promptText) {\n  if(error.length > 0) return \"\";\n  if(runningTests){\n    if(nextInput++ >= testInputs.length) return \"\";\n    return testInputs[nextInput-1];\n  }\n  const terminal = document.getElementById('output-div')\n  customPrintln(promptText);\n  const inputBox = document.createElement('input');\n  inputBox.setAttribute('id', 'input-box-inline');\n  \n  inputBox.style.backgroundColor = \"black\";\n  inputBox.style.color=\"white\";\n  \n  inputBox.style.display = 'inline-block';\n  inputBox.style.marginLeft = '5px';\n  inputBox.style.position = 'relative';\n  inputBox.style.top = '-40px'; \n  inputBox.style.left = ''+(promptText.length*7.5)+'px';\n  terminal.appendChild(inputBox);\n  inputBox.focus();\n\n  return new Promise((resolve) => {\n    const handleKeyDown = (e) => {\n      if (e.key === 'Enter') {\n        e.preventDefault();\n        inputBox.removeEventListener('keydown', handleKeyDown);\n        const answer = inputBox.value.trim();\n        terminal.removeChild(inputBox);\n        resolve(answer);\n      }\n    };\n    inputBox.addEventListener('keydown', handleKeyDown);\n  });\n}\n\n\n\n\n`;\n        static #codeEnding = `})();\n        if(nextInput > testInputs.length) return \"Error: Too many inputs\";\n        if(error.length > 0) return error;\n        return outputString;\n})();\n`;\n        constructor(codeString) {\n            this.#originalCodeString = CodeString.#judge0codeheader;\n            if (arguments.length > 0) {\n                this.addAsyncDeclaration();\n                this.#codeString += codeString;\n                this.#originalCodeString = codeString;\n                this.addVariable('outputString', '\"\"');\n            } else {\n                this.#codeString = '';\n                this.addAsyncDeclaration();\n                this.addVariable('outputString', '\"\"');\n            }\n            this.#userFunctionLinesCount = 0;\n        }\n\n        getCompleteCodeString() {\n            return this.#codeString;\n        }\n\n        getPrintableCodeString() {\n            // Split code by unescaped line breaks (code might have escaped line breaks)\n            const codeLines = this.#codeString\n                .replaceAll(\"customPrintln\", \"print\")\n                .replaceAll(\"text_to_number\", \"parseFloat\")\n                .split(/(?<!\\\\)\\n/);\n\n            // Add lines from start block\n            const startIndex = codeLines.findIndex(line => line.includes('await (async () => {')) + 1;\n            const endIndex = codeLines.findIndex(line => line.includes('})();'));\n            const startCodeLines = codeLines.slice(startIndex, endIndex);\n\n            return startCodeLines.join('\\n');\n        }\n\n        getSubmittableCodeString() {\n            // Replace return outputString; with process.stdout.write(outputString);\n            let lastIndex = this.#codeString.lastIndexOf('return outputString;');\n            return this.#codeString.substring(0, lastIndex) + 'process.stdout.write(outputString);' +\n                this.#codeString.substring(lastIndex + 'return outputString;'.length);\n        }\n\n        getTestableCodeString(){\n            this.#originalCodeString = this.#originalCodeString.replaceAll(\"customPrintln\", \"console.log\");\n            this.#originalCodeString = this.#originalCodeString.replaceAll(\"undefined\", \"\");\n            this.#originalCodeString = this.#originalCodeString.replaceAll(\"await \", \"\");\n            this.#originalCodeString = this.#originalCodeString.replaceAll(\"text_to_number\", \"parseFloat\");\n            return this.#originalCodeString;\n        }\n\n        addVariable(variableName, variableValue) {\n            // Check if variableName is a valid variable name\n            const regex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n            if (!regex.test(variableName)) {\n                throw new Error('Invalid variable name');\n            }\n            this.#codeString += 'let ' + variableName + ' = ' + variableValue + ';\\n';\n            if(variableName !== 'outputString') {\n                this.#originalCodeString += 'let ' + variableName + ' = ' + variableValue + ';\\n';\n            }\n            return this.#codeString;\n        }\n\n        addAsyncDeclaration() {\n            this.#codeString += '(async () => {\\n';\n            return this.#codeString;\n        }\n\n        addLine(line) {\n            // Check if line does not have line break\n            if (line.includes('\\n')) {\n                throw new Error('Invalid line');\n            }\n            this.#codeString += line + '\\n';\n            if(!line.includes(\"async\")){ this.#originalCodeString += line + '\\n'; }\n            return this.#codeString;\n        }\n\n        addEnding() {\n            this.#codeString += CodeString.#codeEnding;\n            return this.#codeString;\n        }\n\n        addAuxFunctions(inputFuncDecs) {\n            const auxFunctions = inputFuncDecs + CodeString.#auxFunctions;\n            this.#codeString += auxFunctions;\n            return this.#codeString;\n        }\n\n        addMainCode(codeString) {\n            this.#codeString += codeString;\n            this.#originalCodeString += codeString;\n            return this.#codeString;\n        }\n\n        addFunction(functionCode) {\n            // Update user function lines count\n            const regex = /(?<!\\\\)\\n/g;\n            const functionLinesCount = (functionCode.match(regex) || []).length;\n            this.#userFunctionLinesCount += functionLinesCount;\n\n            this.#codeString = functionCode + this.#codeString;\n            this.#originalCodeString = functionCode + this.#originalCodeString;\n            return this.#codeString;\n        }\n    }\n    return CodeString;\n});\n"],"names":["define","CodeString","codeString","originalCodeString","userFunctionLinesCount","static","constructor","this","judge0codeheader","arguments","length","addAsyncDeclaration","addVariable","getCompleteCodeString","getPrintableCodeString","codeLines","replaceAll","split","startIndex","findIndex","line","includes","endIndex","slice","join","getSubmittableCodeString","lastIndex","lastIndexOf","substring","getTestableCodeString","variableName","variableValue","test","Error","addLine","addEnding","codeEnding","addAuxFunctions","inputFuncDecs","auxFunctions","addMainCode","addFunction","functionCode","functionLinesCount","match"],"mappings":";;;;;;;AAQAA,OAAM,4BAAC,IAAI,WAEP,MAAMC,WACFC,YACAC,oBACAC,wBACAC,wBAA2B,6PAS3BA,oBACI,89DA2EJA,kBAAqB,uKAMrBC,WAAAA,CAAYJ,YACRK,MAAKJ,mBAAsBF,YAAWO,iBAClCC,UAAUC,OAAS,GACnBH,KAAKI,sBACLJ,MAAKL,YAAeA,WACpBK,MAAKJ,mBAAsBD,WAC3BK,KAAKK,YAAY,eAAgB,QAEjCL,MAAKL,WAAc,GACnBK,KAAKI,sBACLJ,KAAKK,YAAY,eAAgB,OAErCL,MAAKH,uBAA0B,CACnC,CAEAS,qBAAAA,GACI,OAAON,MAAKL,UAChB,CAEAY,sBAAAA,GAEI,MAAMC,UAAYR,MAAKL,WAClBc,WAAW,gBAAiB,SAC5BA,WAAW,iBAAkB,cAC7BC,MAAM,aAGLC,WAAaH,UAAUI,WAAUC,MAAQA,KAAKC,SAAS,0BAA2B,EAClFC,SAAWP,UAAUI,WAAUC,MAAQA,KAAKC,SAAS,WAG3D,OAFuBN,UAAUQ,MAAML,WAAYI,UAE7BE,KAAK,KAC/B,CAEAC,wBAAAA,GAEI,IAAIC,UAAYnB,MAAKL,WAAYyB,YAAY,wBAC7C,OAAOpB,MAAKL,WAAY0B,UAAU,EAAGF,WAAa,sCAC9CnB,MAAKL,WAAY0B,UAAUF,UAAY,GAC/C,CAEAG,qBAAAA,GAKI,OAJAtB,MAAKJ,mBAAsBI,MAAKJ,mBAAoBa,WAAW,gBAAiB,eAChFT,MAAKJ,mBAAsBI,MAAKJ,mBAAoBa,WAAW,YAAa,IAC5ET,MAAKJ,mBAAsBI,MAAKJ,mBAAoBa,WAAW,SAAU,IACzET,MAAKJ,mBAAsBI,MAAKJ,mBAAoBa,WAAW,iBAAkB,cAC1ET,MAAKJ,kBAChB,CAEAS,WAAAA,CAAYkB,aAAcC,eAGtB,IADc,2BACHC,KAAKF,cACZ,MAAM,IAAIG,MAAM,yBAMpB,OAJA1B,MAAKL,YAAe,OAAS4B,aAAe,MAAQC,cAAgB,MAChD,iBAAjBD,eACCvB,MAAKJ,oBAAuB,OAAS2B,aAAe,MAAQC,cAAgB,OAEzExB,MAAKL,UAChB,CAEAS,mBAAAA,GAEI,OADAJ,MAAKL,YAAe,mBACbK,MAAKL,UAChB,CAEAgC,OAAAA,CAAQd,MAEJ,GAAIA,KAAKC,SAAS,MACd,MAAM,IAAIY,MAAM,gBAIpB,OAFA1B,MAAKL,YAAekB,KAAO,KACvBA,KAAKC,SAAS,WAAWd,MAAKJ,oBAAuBiB,KAAO,MACzDb,MAAKL,UAChB,CAEAiC,SAAAA,GAEI,OADA5B,MAAKL,YAAeD,YAAWmC,WACxB7B,MAAKL,UAChB,CAEAmC,eAAAA,CAAgBC,eACZ,MAAMC,aAAeD,cAAgBrC,YAAWsC,aAEhD,OADAhC,MAAKL,YAAeqC,aACbhC,MAAKL,UAChB,CAEAsC,WAAAA,CAAYtC,YAGR,OAFAK,MAAKL,YAAeA,WACpBK,MAAKJ,oBAAuBD,WACrBK,MAAKL,UAChB,CAEAuC,WAAAA,CAAYC,cAER,MACMC,oBAAsBD,aAAaE,MAD3B,eAC2C,IAAIlC,OAK7D,OAJAH,MAAKH,wBAA2BuC,mBAEhCpC,MAAKL,WAAcwC,aAAenC,MAAKL,WACvCK,MAAKJ,mBAAsBuC,aAAenC,MAAKJ,mBACxCI,MAAKL,UAChB,EAEJ,OAAOD,UACX"}