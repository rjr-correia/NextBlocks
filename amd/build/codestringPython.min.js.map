{"version":3,"file":"codestringPython.min.js","sources":["../src/codestringPython.js"],"sourcesContent":["/**\n *\n * @module      mod_nextblocks/codestringPython\n * @copyright   2025 Rui Correia<rjr.correia@campus.fct.unl.pt>\n * @copyright   based on work by 2024 Duarte Pereira<dg.pereira@campus.fct.unl.pt>\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\ndefine([], function() {\n\n    class CodeStringPython {\n        #codeString;\n        #userFunctionLinesCount;\n\n        static #auxFunctions =\n            `\nconst runningTests = false;\nconst testInputs = [];\nconst MAX_ITERATIONS = 10000;\nvar nextInput = 0;\nvar loopIterations = 0;\nvar error = \"\";\n\ncustomPrintln = function(string) {\n  outputString += string + '\\\\n';\n  updateTerminal();\n  return string;\n};\n\nupdateTerminal = function(){\n  if (runningTests) return;\n  const outputDiv = document.getElementById('output-div');\n  if (outputDiv) {\n    outputDiv.innerHTML = \"\";\n    const pre = document.createElement('pre');\n    pre.style.whiteSpace = 'pre-wrap'; \n    pre.textContent = outputString; \n    outputDiv.appendChild(pre);\n  }\n}\n\ntext_to_number = function(string){\n    let result = parseFloat(string);\n    if (isNaN(result)){\n        if (error.length == 0) error = \"Error: Cannot convert \"  + string + \" to a number.\";\n        return 0;\n    }\n    return result;\n}\n\nasync function input(promptText) {\n  if(error.length > 0) return \"\";\n  if(runningTests){\n    if(nextInput++ >= testInputs.length) return \"\";\n    return testInputs[nextInput-1];\n  }\n  const terminal = document.getElementById('output-div')\n  customPrintln(promptText);\n  const inputBox = document.createElement('input');\n  inputBox.setAttribute('id', 'input-box-inline');\n  \n  inputBox.style.backgroundColor = \"black\";\n  inputBox.style.color=\"white\";\n  \n  inputBox.style.display = 'inline-block';\n  inputBox.style.marginLeft = '5px';\n  inputBox.style.position = 'relative';\n  inputBox.style.top = '-40px'; \n  inputBox.style.left = ''+(promptText.length*7.5)+'px';\n  terminal.appendChild(inputBox);\n  inputBox.focus();\n\n  return new Promise((resolve) => {\n    const handleKeyDown = (e) => {\n      if (e.key === 'Enter') {\n        e.preventDefault();\n        inputBox.removeEventListener('keydown', handleKeyDown);\n        const answer = inputBox.value.trim();\n        terminal.removeChild(inputBox);\n        resolve(answer);\n      }\n    };\n    inputBox.addEventListener('keydown', handleKeyDown);\n  });\n}\n\n\n\n\n`;\n        static #codeEnding = `})();\n        if(nextInput > testInputs.length) return \"Error: Too many inputs\";\n        if(error.length > 0) return error;\n        \n        return outputString;\n})();\n`;\n        constructor(codeString) {\n            if (arguments.length > 0) {\n                this.#codeString += codeString;\n                this.addVariable('outputString', '\"\"');\n            } else {\n                this.#codeString = '';\n                this.addVariable('outputString', '\"\"');\n\n\n            }\n            this.#userFunctionLinesCount = 0;\n        }\n\n        getCompleteCodeString() {\n            return this.#codeString;\n        }\n\n        getPrintableCodeString() {\n            // Split code by unescaped line breaks (code might have escaped line breaks)\n            const codeLines = this.#codeString\n                .replaceAll(\"customPrintln\", \"print\")\n                .replaceAll(\"await \", \"\")\n                .replaceAll(\"text_to_number\", \"float\")\n                .split(/(?<!\\\\)\\n/);\n\n            // Add lines from start block\n            const startIndex = codeLines.findIndex(line => line.includes('(async () => {')) + 1;\n            const endIndex = codeLines.findIndex(line => line.includes('})();'));\n            const startCodeLines = codeLines.slice(startIndex, endIndex);\n\n            return startCodeLines.join('\\n');\n        }\n\n        getSubmittableCodeString() {\n            // Replace return outputString; with process.stdout.write(outputString);\n            let lastIndex = this.#codeString.lastIndexOf('return outputString;');\n            return this.#codeString.substring(0, lastIndex) + 'process.stdout.write(outputString);' +\n                this.#codeString.substring(lastIndex + 'return outputString;'.length);\n        }\n\n        addVariable(variableName, variableValue) {\n            // Check if variableName is a valid variable name\n            const regex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n            if (!regex.test(variableName)) {\n                throw new Error('Invalid variable name');\n            }\n            this.#codeString += 'let ' + variableName + ' = ' + variableValue + ';\\n';\n            return this.#codeString;\n        }\n        addLine(line) {\n            // Check if line does not have line break\n            if (line.includes('\\n')) {\n                throw new Error('Invalid line');\n            }\n            this.#codeString += line + '\\n';\n            return this.#codeString;\n        }\n\n        addEnding() {\n            this.#codeString += CodeStringPython.#codeEnding;\n            return this.#codeString;\n        }\n\n        addAuxFunctions(inputFuncDecs) {\n            const auxFunctions = inputFuncDecs + CodeStringPython.#auxFunctions;\n            this.#codeString += auxFunctions;\n            return this.#codeString;\n        }\n\n        addMainCode(codeString) {\n            this.#codeString += codeString;\n            return this.#codeString;\n        }\n\n        addFunction(functionCode) {\n            // Update user function lines count\n            const regex = /(?<!\\\\)\\n/g;\n            const functionLinesCount = (functionCode.match(regex) || []).length;\n            this.#userFunctionLinesCount += functionLinesCount;\n\n            this.#codeString = functionCode + this.#codeString;\n            return this.#codeString;\n        }\n    }\n    return CodeStringPython;\n});\n"],"names":["define","CodeStringPython","codeString","userFunctionLinesCount","static","constructor","arguments","length","this","addVariable","getCompleteCodeString","getPrintableCodeString","codeLines","replaceAll","split","startIndex","findIndex","line","includes","endIndex","slice","join","getSubmittableCodeString","lastIndex","lastIndexOf","substring","variableName","variableValue","test","Error","addLine","addEnding","codeEnding","addAuxFunctions","inputFuncDecs","auxFunctions","addMainCode","addFunction","functionCode","functionLinesCount","match"],"mappings":";;;;;;;AAQAA,OAAM,kCAAC,IAAI,WAEP,MAAMC,iBACFC,YACAC,wBAEAC,oBACI,89DA2EJA,kBAAqB,iLAOrBC,WAAAA,CAAYH,YACJI,UAAUC,OAAS,GACnBC,MAAKN,YAAeA,WACpBM,KAAKC,YAAY,eAAgB,QAEjCD,MAAKN,WAAc,GACnBM,KAAKC,YAAY,eAAgB,OAIrCD,MAAKL,uBAA0B,CACnC,CAEAO,qBAAAA,GACI,OAAOF,MAAKN,UAChB,CAEAS,sBAAAA,GAEI,MAAMC,UAAYJ,MAAKN,WAClBW,WAAW,gBAAiB,SAC5BA,WAAW,SAAU,IACrBA,WAAW,iBAAkB,SAC7BC,MAAM,aAGLC,WAAaH,UAAUI,WAAUC,MAAQA,KAAKC,SAAS,oBAAqB,EAC5EC,SAAWP,UAAUI,WAAUC,MAAQA,KAAKC,SAAS,WAG3D,OAFuBN,UAAUQ,MAAML,WAAYI,UAE7BE,KAAK,KAC/B,CAEAC,wBAAAA,GAEI,IAAIC,UAAYf,MAAKN,WAAYsB,YAAY,wBAC7C,OAAOhB,MAAKN,WAAYuB,UAAU,EAAGF,WAAa,sCAC9Cf,MAAKN,WAAYuB,UAAUF,UAAY,GAC/C,CAEAd,WAAAA,CAAYiB,aAAcC,eAGtB,IADc,2BACHC,KAAKF,cACZ,MAAM,IAAIG,MAAM,yBAGpB,OADArB,MAAKN,YAAe,OAASwB,aAAe,MAAQC,cAAgB,MAC7DnB,MAAKN,UAChB,CACA4B,OAAAA,CAAQb,MAEJ,GAAIA,KAAKC,SAAS,MACd,MAAM,IAAIW,MAAM,gBAGpB,OADArB,MAAKN,YAAee,KAAO,KACpBT,MAAKN,UAChB,CAEA6B,SAAAA,GAEI,OADAvB,MAAKN,YAAeD,kBAAiB+B,WAC9BxB,MAAKN,UAChB,CAEA+B,eAAAA,CAAgBC,eACZ,MAAMC,aAAeD,cAAgBjC,kBAAiBkC,aAEtD,OADA3B,MAAKN,YAAeiC,aACb3B,MAAKN,UAChB,CAEAkC,WAAAA,CAAYlC,YAER,OADAM,MAAKN,YAAeA,WACbM,MAAKN,UAChB,CAEAmC,WAAAA,CAAYC,cAER,MACMC,oBAAsBD,aAAaE,MAD3B,eAC2C,IAAIjC,OAI7D,OAHAC,MAAKL,wBAA2BoC,mBAEhC/B,MAAKN,WAAcoC,aAAe9B,MAAKN,WAChCM,MAAKN,UAChB,EAEJ,OAAOD,gBACX"}